/**
 * VulnerabilityMatcher
 *
 * Improves vulnerability detection by matching called functions
 * against known vulnerable functions from vulnerability databases.
 *
 * This is a GENERIC approach - no hardcoded vulnerabilities!
 */

class VulnerabilityMatcher {
    constructor() {
        // Cache for function-level vulnerability matching
        this.functionVulnCache = new Map();
    }

    /**
     * Checks if a specific function call matches known vulnerable functions
     *
     * @param {string} packageName - Package name (e.g., "lodash")
     * @param {string} functionCall - Function called (e.g., "template", "lodash.template")
     * @param {Array} vulnerabilities - Array of vulnerability objects from OSV
     * @returns {Object} { matched: boolean, matchedVulns: Array, confidence: number }
     */
    matchFunctionToVulnerability(packageName, functionCall, vulnerabilities) {
        const cacheKey = `${packageName}:${functionCall}`;

        if (this.functionVulnCache.has(cacheKey)) {
            return this.functionVulnCache.get(cacheKey);
        }

        const result = this._performMatch(packageName, functionCall, vulnerabilities);
        this.functionVulnCache.set(cacheKey, result);

        return result;
    }

    /**
     * Internal matching logic
     */
    _performMatch(packageName, functionCall, vulnerabilities) {
        if (!vulnerabilities || vulnerabilities.length === 0) {
            return { matched: false, matchedVulns: [], confidence: 0.5 };
        }

        const matchedVulns = [];
        let highestConfidence = 0.5; // Base confidence

        for (const vuln of vulnerabilities) {
            const matchResult = this._matchSingleVulnerability(functionCall, vuln);

            if (matchResult.matched) {
                matchedVulns.push({
                    vulnerability: vuln,
                    matchType: matchResult.matchType,
                    matchedFunction: matchResult.matchedFunction
                });

                highestConfidence = Math.max(highestConfidence, matchResult.confidence);
            }
        }

        return {
            matched: matchedVulns.length > 0,
            matchedVulns,
            confidence: matchedVulns.length > 0 ? highestConfidence : 0.5
        };
    }

    /**
     * Match a function call against a single vulnerability's affected functions
     */
    _matchSingleVulnerability(functionCall, vuln) {
        // OSV format: affectedFunctions array
        if (vuln.affectedFunctions && Array.isArray(vuln.affectedFunctions)) {
            for (const affectedFunc of vuln.affectedFunctions) {
                if (this._functionsMatch(functionCall, affectedFunc)) {
                    return {
                        matched: true,
                        matchType: 'explicit',
                        matchedFunction: affectedFunc,
                        confidence: 0.95
                    };
                }
            }
        }

        // Check vulnerability description for function mentions (heuristic)
        if (vuln.summary || vuln.details) {
            const text = (vuln.summary || '') + ' ' + (vuln.details || '');
            const funcName = this._extractFunctionName(functionCall);

            if (funcName && this._mentionsFunction(text, funcName)) {
                return {
                    matched: true,
                    matchType: 'description-heuristic',
                    matchedFunction: funcName,
                    confidence: 0.70
                };
            }
        }

        // No match - but package is imported so medium confidence
        return {
            matched: false,
            matchType: 'package-import-only',
            confidence: 0.50
        };
    }

    /**
     * Check if two function signatures match
     */
    _functionsMatch(calledFunc, affectedFunc) {
        // Exact match
        if (calledFunc === affectedFunc) {
            return true;
        }

        // Normalize and compare
        const called = this._normalizeFunctionName(calledFunc);
        const affected = this._normalizeFunctionName(affectedFunc);

        if (called === affected) {
            return true;
        }

        // Check if called function ends with affected function
        // e.g., "lodash.template" contains "template"
        if (called.endsWith('.' + affected) || called.endsWith('/' + affected)) {
            return true;
        }

        return false;
    }

    /**
     * Normalize function names for comparison
     */
    _normalizeFunctionName(funcName) {
        return funcName
            .toLowerCase()
            .replace(/[_\-]/g, '')
            .replace(/^.*[\/.:]/, ''); // Remove package prefix
    }

    /**
     * Extract function name from full call
     */
    _extractFunctionName(functionCall) {
        // Extract last part after . or /
        const match = functionCall.match(/([a-zA-Z0-9_]+)$/);
        return match ? match[1] : functionCall;
    }

    /**
     * Check if vulnerability description mentions a function
     * Uses NLP-like heuristics without hardcoding specific vulnerabilities
     */
    _mentionsFunction(text, funcName) {
        const patterns = [
            // Direct mentions
            new RegExp(`\\b${funcName}\\b`, 'i'),
            new RegExp(`\\b${funcName}\\(\\)`, 'i'),

            // Common vulnerability description patterns
            new RegExp(`in\\s+${funcName}`, 'i'),
            new RegExp(`${funcName}\\s+function`, 'i'),
            new RegExp(`${funcName}\\s+method`, 'i'),
            new RegExp(`using\\s+${funcName}`, 'i'),
            new RegExp(`via\\s+${funcName}`, 'i'),

            // Code-like mentions
            new RegExp(`\\.${funcName}\\(`, 'i'),
            new RegExp(`::${funcName}`, 'i')
        ];

        return patterns.some(pattern => pattern.test(text));
    }

    /**
     * Calculate enhanced confidence score based on multiple factors
     *
     * @param {Object} options - Scoring factors
     * @returns {number} Confidence score 0-1
     */
    calculateEnhancedConfidence(options = {}) {
        const {
            callDepth = 0,
            isConditional = false,
            isErrorPath = false,
            isBackgroundJob = false,
            hasDirectFunctionMatch = false,
            hasDescriptionMatch = false,
            hasPackageImport = false
        } = options;

        let confidence = 1.0;

        // Function-level matching boosts confidence
        if (hasDirectFunctionMatch) {
            confidence = 0.95;
        } else if (hasDescriptionMatch) {
            confidence = 0.75;
        } else if (hasPackageImport) {
            confidence = 0.60;
        } else {
            confidence = 0.40; // Very uncertain
        }

        // Apply penalties for complex call paths
        const depthPenalty = Math.min(callDepth * 0.05, 0.25);
        confidence -= depthPenalty;

        // Conditional loading penalty
        if (isConditional) {
            confidence -= 0.10;
        }

        // Error path penalty
        if (isErrorPath) {
            confidence -= 0.08;
        }

        // Background job penalty
        if (isBackgroundJob) {
            confidence -= 0.15;
        }

        // Ensure confidence stays in valid range
        return Math.max(0.10, Math.min(1.0, confidence));
    }

    /**
     * Clear caches (useful for testing)
     */
    clearCache() {
        this.functionVulnCache.clear();
    }
}

module.exports = VulnerabilityMatcher;
