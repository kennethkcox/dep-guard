/**
 * Vulnerability Database Manager
 * Integrates with various vulnerability databases (NVD, OSV, GitHub Advisory)
 */

const fs = require('fs');
const path = require('path');

class VulnerabilityDatabase {
  constructor(options = {}) {
    this.options = options;
    this.vulnerabilities = new Map(); // package@version -> [vulns]
    this.functionVulnerabilities = new Map(); // package -> {function -> vulns}
    this.cacheDir = options.cacheDir || path.join(process.cwd(), '.depguard-cache');
    this.initializeCache();
  }

  /**
   * Initializes cache directory
   */
  initializeCache() {
    if (!fs.existsSync(this.cacheDir)) {
      fs.mkdirSync(this.cacheDir, { recursive: true });
    }
  }

  /**
   * Loads vulnerability data from various sources
   */
  async loadVulnerabilities(packages) {
    console.log(`Loading vulnerabilities for ${packages.length} packages...`);

    for (const pkg of packages) {
      await this.fetchPackageVulnerabilities(pkg);
    }

    console.log(`Loaded vulnerabilities for ${this.vulnerabilities.size} packages`);
  }

  /**
   * Fetches vulnerabilities for a specific package
   */
  async fetchPackageVulnerabilities(packageInfo) {
    const { name, version } = packageInfo;
    const cacheKey = `${name}@${version}`;

    // Check cache first
    const cached = this.loadFromCache(cacheKey);
    if (cached) {
      this.vulnerabilities.set(cacheKey, cached);
      return cached;
    }

    // Fetch from sources
    const vulns = [];

    // OSV Database (open-source vulnerability database)
    const osvVulns = await this.fetchFromOSV(name, version);
    vulns.push(...osvVulns);

    // GitHub Advisory Database
    const ghVulns = await this.fetchFromGitHubAdvisory(name, version);
    vulns.push(...ghVulns);

    // Snyk Database (if configured)
    if (this.options.snykToken) {
      const snykVulns = await this.fetchFromSnyk(name, version);
      vulns.push(...snykVulns);
    }

    // Process and enrich vulnerabilities
    const processedVulns = this.processVulnerabilities(vulns, name, version);

    // Cache results
    this.saveToCache(cacheKey, processedVulns);
    this.vulnerabilities.set(cacheKey, processedVulns);

    return processedVulns;
  }

  /**
   * Fetches from OSV database (simulated - would use actual API)
   */
  async fetchFromOSV(packageName, version) {
    // In production, this would make HTTP request to https://api.osv.dev/v1/query
    // For now, using sample data

    const sampleVulns = this.getSampleVulnerabilities(packageName, version);
    return sampleVulns.filter(v => v.source === 'OSV');
  }

  /**
   * Fetches from GitHub Advisory Database (simulated)
   */
  async fetchFromGitHubAdvisory(packageName, version) {
    // In production, would use GitHub GraphQL API
    const sampleVulns = this.getSampleVulnerabilities(packageName, version);
    return sampleVulns.filter(v => v.source === 'GitHub');
  }

  /**
   * Fetches from Snyk (simulated)
   */
  async fetchFromSnyk(packageName, version) {
    // In production, would use Snyk API
    return [];
  }

  /**
   * Returns sample vulnerability data for testing
   */
  getSampleVulnerabilities(packageName, version) {
    const vulnDatabase = {
      'lodash': [
        {
          id: 'CVE-2021-23337',
          source: 'OSV',
          title: 'Prototype Pollution in lodash',
          description: 'Command injection vulnerability in lodash template functionality',
          severity: 'CRITICAL',
          cvss: 9.8,
          affectedVersions: ['<4.17.21'],
          fixedVersion: '4.17.21',
          exploitMaturity: 'proof-of-concept',
          vulnerableFunctions: [
            { path: 'lodash/template.js', function: 'template', line: 254 },
            { path: 'lodash.js', function: 'template', line: 1538 }
          ],
          references: [
            'https://nvd.nist.gov/vuln/detail/CVE-2021-23337',
            'https://github.com/lodash/lodash/pull/5065'
          ]
        }
      ],
      'axios': [
        {
          id: 'CVE-2023-45857',
          source: 'GitHub',
          title: 'Server-Side Request Forgery in axios',
          description: 'Axios allows SSRF via URL parameter injection',
          severity: 'HIGH',
          cvss: 7.5,
          affectedVersions: ['>=0.8.1 <1.6.0'],
          fixedVersion: '1.6.0',
          exploitMaturity: 'functional',
          vulnerableFunctions: [
            { path: 'lib/adapters/http.js', function: 'httpAdapter', line: 89 },
            { path: 'lib/core/dispatchRequest.js', function: 'dispatchRequest', line: 52 }
          ],
          references: [
            'https://github.com/axios/axios/issues/6006'
          ]
        }
      ],
      'express': [
        {
          id: 'CVE-2022-24999',
          source: 'OSV',
          title: 'Open Redirect in express',
          description: 'Express vulnerable to open redirect via malicious query parameters',
          severity: 'MEDIUM',
          cvss: 6.1,
          affectedVersions: ['<4.17.3'],
          fixedVersion: '4.17.3',
          exploitMaturity: 'high',
          vulnerableFunctions: [
            { path: 'lib/response.js', function: 'redirect', line: 912 }
          ],
          references: [
            'https://github.com/expressjs/express/releases/tag/4.17.3'
          ]
        }
      ],
      'jsonwebtoken': [
        {
          id: 'CVE-2022-23529',
          source: 'GitHub',
          title: 'Improper Signature Verification',
          description: 'JWT signature verification bypass',
          severity: 'CRITICAL',
          cvss: 9.1,
          affectedVersions: ['<9.0.0'],
          fixedVersion: '9.0.0',
          exploitMaturity: 'proof-of-concept',
          vulnerableFunctions: [
            { path: 'verify.js', function: 'verify', line: 145 },
            { path: 'decode.js', function: 'decode', line: 23 }
          ],
          references: [
            'https://github.com/auth0/node-jsonwebtoken/security/advisories/GHSA-hjrf-2m68-5959'
          ]
        }
      ]
    };

    return vulnDatabase[packageName] || [];
  }

  /**
   * Processes and enriches vulnerability data
   */
  processVulnerabilities(vulns, packageName, version) {
    return vulns.map(vuln => {
      const isAffected = this.isVersionAffected(version, vuln.affectedVersions);

      return {
        ...vuln,
        package: packageName,
        version,
        isAffected,
        reachabilityScore: 0, // Will be updated by reachability analysis
        priority: this.calculatePriority(vuln)
      };
    }).filter(v => v.isAffected);
  }

  /**
   * Checks if a version is affected by vulnerability
   */
  isVersionAffected(version, affectedVersions) {
    // Simple version check - in production would use semver library
    if (!affectedVersions || affectedVersions.length === 0) return true;

    for (const range of affectedVersions) {
      if (range.includes('<')) {
        const compareVersion = range.replace(/[<>=]/g, '').trim();
        // Simplified comparison
        return this.compareVersions(version, compareVersion) < 0;
      }
    }

    return true;
  }

  /**
   * Simple version comparison
   */
  compareVersions(v1, v2) {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const p1 = parts1[i] || 0;
      const p2 = parts2[i] || 0;
      if (p1 !== p2) return p1 - p2;
    }

    return 0;
  }

  /**
   * Calculates priority score for vulnerability
   */
  calculatePriority(vuln) {
    let score = vuln.cvss || 5.0;

    // Boost based on exploit maturity
    const exploitBoost = {
      'high': 2.0,
      'functional': 1.5,
      'proof-of-concept': 1.0,
      'unproven': 0.5
    };

    score += exploitBoost[vuln.exploitMaturity] || 0;

    // Boost for critical severity
    if (vuln.severity === 'CRITICAL') score += 1.0;

    return Math.min(10, score);
  }

  /**
   * Maps vulnerabilities to specific functions
   */
  mapVulnerableFunction(packageName, modulePath, functionName, vulnerability) {
    if (!this.functionVulnerabilities.has(packageName)) {
      this.functionVulnerabilities.set(packageName, new Map());
    }

    const funcMap = this.functionVulnerabilities.get(packageName);
    const key = `${modulePath}:${functionName}`;

    if (!funcMap.has(key)) {
      funcMap.set(key, []);
    }

    funcMap.get(key).push(vulnerability);
  }

  /**
   * Gets all vulnerabilities for a package
   */
  getVulnerabilities(packageName, version) {
    return this.vulnerabilities.get(`${packageName}@${version}`) || [];
  }

  /**
   * Loads from cache
   */
  loadFromCache(key) {
    const cacheFile = path.join(this.cacheDir, `${key.replace(/[^a-z0-9]/gi, '_')}.json`);

    if (fs.existsSync(cacheFile)) {
      try {
        const data = fs.readFileSync(cacheFile, 'utf-8');
        const cached = JSON.parse(data);

        // Check if cache is expired (24 hours)
        if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
          return cached.data;
        }
      } catch (error) {
        // Cache read failed, will fetch fresh data
      }
    }

    return null;
  }

  /**
   * Saves to cache
   */
  saveToCache(key, data) {
    const cacheFile = path.join(this.cacheDir, `${key.replace(/[^a-z0-9]/gi, '_')}.json`);

    try {
      fs.writeFileSync(cacheFile, JSON.stringify({
        timestamp: Date.now(),
        data
      }), 'utf-8');
    } catch (error) {
      console.error(`Failed to save cache: ${error.message}`);
    }
  }

  /**
   * Clears cache
   */
  clearCache() {
    if (fs.existsSync(this.cacheDir)) {
      const files = fs.readdirSync(this.cacheDir);
      files.forEach(file => {
        fs.unlinkSync(path.join(this.cacheDir, file));
      });
    }
  }
}

module.exports = VulnerabilityDatabase;
