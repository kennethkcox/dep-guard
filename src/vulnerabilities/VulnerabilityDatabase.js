/**
 * GENERIC Vulnerability Database Manager
 * NO hardcoded vulnerabilities - uses REAL APIs
 * Works with ANY project structure, ANY vulnerabilities
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const OSVDatabase = require('./OSVDatabase');
const Validator = require('../utils/validator');
const { FileSystemError, VulnerabilityFetchError } = require('../utils/errors');
const { getLogger } = require('../utils/logger');

// Optional multi-source dependencies - loaded on demand
let NVDDatabase, GitHubAdvisoryDatabase, EPSSEnricher, CISAKEVChecker;
try {
  NVDDatabase = require('./NVDDatabase');
  GitHubAdvisoryDatabase = require('./GitHubAdvisoryDatabase');
  EPSSEnricher = require('./EPSSEnricher');
  CISAKEVChecker = require('./CISAKEVChecker');
} catch (e) {
  // Graceful degradation if any source module is missing
}

class VulnerabilityDatabase {
  constructor(options = {}) {
    this.options = options;
    this.vulnerabilities = new Map(); // package@version -> [vulns]
    this.functionVulnerabilities = new Map(); // package -> {function -> vulns}
    this.cacheDir = options.cacheDir || path.join(process.cwd(), '.depguard-cache');
    this.ecosystem = options.ecosystem || 'javascript';
    this.logger = getLogger().child({ component: 'VulnerabilityDatabase' });

    // Security: cache integrity secret (should be configurable in production)
    this.cacheSecret = options.cacheSecret || 'depguard-default-secret-change-in-production';

    // Primary source: OSV Database (always enabled)
    this.osvDb = new OSVDatabase(options);

    // Additional vulnerability sources
    this.enabledSources = {
      osv: true,
      nvd: options.enableNVD === true || !!options.nvdApiKey || !!process.env.NVD_API_KEY,
      github: options.enableGitHub === true || !!options.githubToken || !!process.env.GITHUB_TOKEN,
      epss: options.disableEPSS !== true,
      kev: options.disableKEV !== true
    };

    // Initialize additional sources when available
    this.nvdDb = null;
    this.githubDb = null;
    this.epssEnricher = null;
    this.kevChecker = null;

    if (this.enabledSources.nvd && NVDDatabase) {
      this.nvdDb = new NVDDatabase(options);
      this.logger.info('NVD database enabled');
    }

    if (this.enabledSources.github && GitHubAdvisoryDatabase) {
      this.githubDb = new GitHubAdvisoryDatabase(options);
      this.logger.info('GitHub Advisory database enabled');
    }

    if (this.enabledSources.epss && EPSSEnricher) {
      this.epssEnricher = new EPSSEnricher(options);
      this.logger.info('EPSS enrichment enabled');
    }

    if (this.enabledSources.kev && CISAKEVChecker) {
      this.kevChecker = new CISAKEVChecker(options);
      this.logger.info('CISA KEV checking enabled');
    }

    this.kevInitialized = false;

    this.initializeCache();
  }

  /**
   * Initializes cache directory
   */
  initializeCache() {
    try {
      if (!fs.existsSync(this.cacheDir)) {
        fs.mkdirSync(this.cacheDir, { recursive: true });
        this.logger.debug('Created cache directory', { cacheDir: this.cacheDir });
      }
    } catch (error) {
      throw new FileSystemError(
        `Failed to create cache directory: ${error.message}`,
        this.cacheDir,
        'mkdir'
      );
    }
  }

  /**
   * Initialize KEV catalog if enabled (one-time)
   */
  async initializeKEV() {
    if (this.kevInitialized || !this.kevChecker) return;
    try {
      await this.kevChecker.initialize();
      this.kevInitialized = true;
      this.logger.info('CISA KEV catalog initialized');
    } catch (error) {
      this.logger.warn('Failed to initialize KEV catalog', { error: error.message });
    }
  }

  /**
   * Loads vulnerability data from all enabled sources
   */
  async loadVulnerabilities(packages) {
    const sourceNames = Object.entries(this.enabledSources)
      .filter(([, v]) => v)
      .map(([k]) => k.toUpperCase());
    this.logger.info(`Loading vulnerabilities for ${packages.length} packages from: ${sourceNames.join(', ')}`);

    // Validate dependency count
    Validator.validateDependencyCount(packages.length);

    // Initialize KEV catalog if enabled
    await this.initializeKEV();

    // Phase 1: Query OSV (primary, supports batch)
    try {
      const vulns = await this.osvDb.queryBatch(packages, this.ecosystem);

      vulns.forEach(vuln => {
        const cacheKey = `${vuln.package}@${vuln.version}`;

        if (!this.vulnerabilities.has(cacheKey)) {
          this.vulnerabilities.set(cacheKey, []);
        }

        vuln.sources = ['OSV'];
        this.vulnerabilities.get(cacheKey).push(vuln);
      });

      this.logger.info(`OSV: Found ${vulns.length} vulnerabilities across ${this.vulnerabilities.size} packages`);
    } catch (error) {
      this.logger.error('Error loading vulnerabilities from OSV', { error: error.message });
      this.logger.info('Falling back to cache');

      // Fallback to cache for each package
      for (const pkg of packages) {
        try {
          await this.fetchPackageVulnerabilities(pkg);
        } catch (pkgError) {
          this.logger.warn('Failed to fetch vulnerabilities for package', {
            package: pkg.name,
            error: pkgError.message
          });
        }
      }
    }

    // Phase 2: Query additional sources for packages that have vulnerabilities
    // (or for all packages if configured for broader coverage)
    await this.queryAdditionalSources(packages);

    // Phase 3: Enrich all found vulnerabilities with EPSS and KEV
    await this.enrichVulnerabilities();
  }

  /**
   * Query NVD and GitHub Advisory for additional vulnerability data
   */
  async queryAdditionalSources(packages) {
    const packagesToQuery = packages;

    // Query GitHub Advisory Database
    if (this.githubDb && this.githubDb.githubToken) {
      let githubCount = 0;
      for (const pkg of packagesToQuery) {
        try {
          const ghVulns = await this.githubDb.queryByPackage(pkg.name, this.ecosystem);
          if (ghVulns && ghVulns.length > 0) {
            const cacheKey = `${pkg.name}@${pkg.version}`;
            if (!this.vulnerabilities.has(cacheKey)) {
              this.vulnerabilities.set(cacheKey, []);
            }

            const existing = this.vulnerabilities.get(cacheKey);
            for (const ghVuln of ghVulns) {
              // Deduplicate by CVE/GHSA ID
              const isDuplicate = existing.some(v =>
                (v.id && ghVuln.id && v.id === ghVuln.id) ||
                (v.cve && ghVuln.cve && v.cve === ghVuln.cve) ||
                (v.ghsaId && ghVuln.ghsaId && v.ghsaId === ghVuln.ghsaId)
              );

              if (!isDuplicate) {
                ghVuln.sources = ['GitHub'];
                ghVuln.package = pkg.name;
                ghVuln.version = pkg.version;
                existing.push(ghVuln);
                githubCount++;
              } else {
                // Merge source info into existing entry
                const match = existing.find(v =>
                  (v.id && ghVuln.id && v.id === ghVuln.id) ||
                  (v.cve && ghVuln.cve && v.cve === ghVuln.cve)
                );
                if (match && match.sources && !match.sources.includes('GitHub')) {
                  match.sources.push('GitHub');
                }
              }
            }
          }
        } catch (error) {
          this.logger.debug('GitHub query failed for package', {
            package: pkg.name,
            error: error.message
          });
        }
      }
      if (githubCount > 0) {
        this.logger.info(`GitHub Advisory: Found ${githubCount} additional vulnerabilities`);
      }
    }

    // Query NVD (rate-limited, only query for packages with known vulns to reduce API calls)
    if (this.nvdDb && (this.nvdDb.apiKey || process.env.NVD_API_KEY)) {
      let nvdCount = 0;
      const packagesWithVulns = packagesToQuery.filter(pkg =>
        this.vulnerabilities.has(`${pkg.name}@${pkg.version}`)
      );

      for (const pkg of packagesWithVulns) {
        try {
          const nvdVulns = await this.nvdDb.queryByKeyword(pkg.name, this.ecosystem);
          if (nvdVulns && nvdVulns.length > 0) {
            const cacheKey = `${pkg.name}@${pkg.version}`;
            const existing = this.vulnerabilities.get(cacheKey) || [];

            for (const nvdVuln of nvdVulns) {
              const isDuplicate = existing.some(v =>
                (v.id && nvdVuln.id && v.id === nvdVuln.id) ||
                (v.cve && nvdVuln.cve && v.cve === nvdVuln.cve)
              );

              if (!isDuplicate) {
                nvdVuln.sources = ['NVD'];
                nvdVuln.package = pkg.name;
                nvdVuln.version = pkg.version;
                existing.push(nvdVuln);
                nvdCount++;
              } else {
                // Enrich existing entry with NVD data (CVSS, CWE)
                const match = existing.find(v =>
                  (v.cve && nvdVuln.cve && v.cve === nvdVuln.cve)
                );
                if (match) {
                  if (!match.sources) match.sources = [];
                  if (!match.sources.includes('NVD')) match.sources.push('NVD');
                  // NVD often has better CVSS scores
                  if (nvdVuln.cvssV3 && !match.cvssV3) match.cvssV3 = nvdVuln.cvssV3;
                  if (nvdVuln.cwe && !match.cwe) match.cwe = nvdVuln.cwe;
                }
              }
            }
          }
        } catch (error) {
          this.logger.debug('NVD query failed for package', {
            package: pkg.name,
            error: error.message
          });
        }
      }
      if (nvdCount > 0) {
        this.logger.info(`NVD: Found ${nvdCount} additional vulnerabilities`);
      }
    }
  }

  /**
   * Enrich all found vulnerabilities with EPSS scores and KEV data
   */
  async enrichVulnerabilities() {
    let epssEnriched = 0;
    let kevFound = 0;

    for (const [cacheKey, vulns] of this.vulnerabilities) {
      for (const vuln of vulns) {
        // EPSS enrichment
        if (this.epssEnricher && (vuln.cve || vuln.id)) {
          try {
            const cveId = vuln.cve || vuln.id;
            if (cveId && cveId.startsWith('CVE-')) {
              const enriched = await this.epssEnricher.enrichVulnerability(vuln);
              if (enriched.epss) {
                Object.assign(vuln, enriched);
                epssEnriched++;
              }
            }
          } catch (error) {
            // EPSS enrichment is best-effort
          }
        }

        // KEV enrichment
        if (this.kevChecker && this.kevInitialized && (vuln.cve || vuln.id)) {
          try {
            const enriched = this.kevChecker.enrichVulnerability(vuln);
            if (enriched.kev) {
              Object.assign(vuln, enriched);
              kevFound++;
            }
          } catch (error) {
            // KEV enrichment is best-effort
          }
        }
      }

      // Update cache with enriched data
      this.saveToCache(cacheKey, vulns);
    }

    if (epssEnriched > 0) {
      this.logger.info(`EPSS: Enriched ${epssEnriched} vulnerabilities with exploit probability scores`);
    }
    if (kevFound > 0) {
      this.logger.info(`CISA KEV: Found ${kevFound} actively exploited vulnerabilities`);
    }
  }

  /**
   * Fetches vulnerabilities for a specific package from REAL APIs
   */
  async fetchPackageVulnerabilities(packageInfo) {
    const { name, version } = packageInfo;
    const cacheKey = `${name}@${version}`;

    // Check cache first with integrity validation
    const cached = this.loadFromCache(cacheKey);
    if (cached) {
      this.vulnerabilities.set(cacheKey, cached);
      this.logger.debug('Loaded vulnerabilities from cache', { package: name, count: cached.length });
      return cached;
    }

    // Fetch from REAL OSV API
    try {
      this.logger.debug(`Querying OSV for ${name}@${version}`);
      const vulns = await this.osvDb.query(name, version, this.ecosystem);

      if (vulns.length > 0) {
        this.logger.info(`Found ${vulns.length} vulnerabilities for ${name}`);
      }

      // Cache results with integrity signature
      this.saveToCache(cacheKey, vulns);
      this.vulnerabilities.set(cacheKey, vulns);

      return vulns;
    } catch (error) {
      throw new VulnerabilityFetchError(
        `Failed to fetch vulnerabilities: ${error.message}`,
        name,
        { version, ecosystem: this.ecosystem }
      );
    }
  }

  /**
   * Maps vulnerabilities to specific functions in the call graph
   */
  mapVulnerableFunction(packageName, modulePath, functionName, vulnerability) {
    if (!this.functionVulnerabilities.has(packageName)) {
      this.functionVulnerabilities.set(packageName, new Map());
    }

    const funcMap = this.functionVulnerabilities.get(packageName);
    const key = `${modulePath}:${functionName}`;

    if (!funcMap.has(key)) {
      funcMap.set(key, []);
    }

    funcMap.get(key).push(vulnerability);
  }

  /**
   * Gets all vulnerabilities for a package
   */
  getVulnerabilities(packageName, version) {
    return this.vulnerabilities.get(`${packageName}@${version}`) || [];
  }

  /**
   * Loads from cache with integrity validation
   */
  loadFromCache(key) {
    const sanitizedKey = Validator.sanitizeCacheKey(key);
    const cacheFile = path.join(this.cacheDir, `${sanitizedKey}.json`);

    if (!fs.existsSync(cacheFile)) {
      return null;
    }

    try {
      // Validate file size before reading
      Validator.validateFileSize(cacheFile, 50 * 1024 * 1024); // Max 50MB cache file

      const data = fs.readFileSync(cacheFile, 'utf-8');

      // Validate JSON size before parsing
      Validator.validateJSONSize(data);

      const cached = JSON.parse(data);

      // Verify cache integrity using HMAC
      if (!this.verifyCacheIntegrity(cached)) {
        this.logger.warn('Cache integrity verification failed, ignoring cache', { key });
        return null;
      }

      // Check if cache is expired (24 hours)
      if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
        return cached.data;
      }

      this.logger.debug('Cache expired', { key, age: Date.now() - cached.timestamp });
    } catch (error) {
      this.logger.warn('Failed to load from cache', { key, error: error.message });
    }

    return null;
  }

  /**
   * Saves to cache with integrity signature
   */
  saveToCache(key, data) {
    const sanitizedKey = Validator.sanitizeCacheKey(key);
    const cacheFile = path.join(this.cacheDir, `${sanitizedKey}.json`);

    try {
      const cacheData = {
        timestamp: Date.now(),
        data
      };

      // Add HMAC signature for integrity verification
      cacheData.signature = this.generateCacheSignature(cacheData);

      fs.writeFileSync(cacheFile, JSON.stringify(cacheData), 'utf-8');
      this.logger.debug('Saved to cache', { key });
    } catch (error) {
      this.logger.error('Failed to save cache', { key, error: error.message });
      // Don't throw - caching is not critical
    }
  }

  /**
   * Generates HMAC signature for cache data integrity
   */
  generateCacheSignature(cacheData) {
    const { data, timestamp } = cacheData;
    const content = JSON.stringify({ data, timestamp });
    return crypto.createHmac('sha256', this.cacheSecret)
      .update(content)
      .digest('hex');
  }

  /**
   * Verifies cache data integrity using HMAC
   */
  verifyCacheIntegrity(cacheData) {
    if (!cacheData.signature) {
      return false; // No signature, can't verify
    }

    const expectedSignature = this.generateCacheSignature(cacheData);
    return cacheData.signature === expectedSignature;
  }

  /**
   * Clears cache
   */
  clearCache() {
    try {
      if (fs.existsSync(this.cacheDir)) {
        const files = fs.readdirSync(this.cacheDir);
        files.forEach(file => {
          const filePath = path.join(this.cacheDir, file);
          fs.unlinkSync(filePath);
        });
        this.logger.info('Cache cleared', { fileCount: files.length });
      }
    } catch (error) {
      throw new FileSystemError(
        `Failed to clear cache: ${error.message}`,
        this.cacheDir,
        'clear'
      );
    }
  }
}

module.exports = VulnerabilityDatabase;
