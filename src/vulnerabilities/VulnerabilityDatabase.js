/**
 * GENERIC Vulnerability Database Manager
 * NO hardcoded vulnerabilities - uses REAL APIs
 * Works with ANY project structure, ANY vulnerabilities
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const OSVDatabase = require('./OSVDatabase');
const Validator = require('../utils/validator');
const { FileSystemError, VulnerabilityFetchError } = require('../utils/errors');
const { getLogger } = require('../utils/logger');

class VulnerabilityDatabase {
  constructor(options = {}) {
    this.options = options;
    this.vulnerabilities = new Map(); // package@version -> [vulns]
    this.functionVulnerabilities = new Map(); // package -> {function -> vulns}
    this.cacheDir = options.cacheDir || path.join(process.cwd(), '.depguard-cache');
    this.ecosystem = options.ecosystem || 'javascript';
    this.logger = getLogger().child({ component: 'VulnerabilityDatabase' });

    // Security: cache integrity secret (should be configurable in production)
    this.cacheSecret = options.cacheSecret || 'depguard-default-secret-change-in-production';

    // Use REAL OSV Database
    this.osvDb = new OSVDatabase(options);

    this.initializeCache();
  }

  /**
   * Initializes cache directory
   */
  initializeCache() {
    try {
      if (!fs.existsSync(this.cacheDir)) {
        fs.mkdirSync(this.cacheDir, { recursive: true });
        this.logger.debug('Created cache directory', { cacheDir: this.cacheDir });
      }
    } catch (error) {
      throw new FileSystemError(
        `Failed to create cache directory: ${error.message}`,
        this.cacheDir,
        'mkdir'
      );
    }
  }

  /**
   * Loads vulnerability data from REAL sources
   */
  async loadVulnerabilities(packages) {
    this.logger.info(`Loading vulnerabilities for ${packages.length} packages from OSV`);

    // Validate dependency count
    Validator.validateDependencyCount(packages.length);

    // Use batch query for efficiency
    try {
      const vulns = await this.osvDb.queryBatch(packages, this.ecosystem);

      vulns.forEach(vuln => {
        const cacheKey = `${vuln.package}@${vuln.version}`;

        if (!this.vulnerabilities.has(cacheKey)) {
          this.vulnerabilities.set(cacheKey, []);
        }

        this.vulnerabilities.get(cacheKey).push(vuln);

        // Cache it with integrity check
        this.saveToCache(cacheKey, this.vulnerabilities.get(cacheKey));
      });

      this.logger.info(`Found vulnerabilities in ${this.vulnerabilities.size} packages`);
    } catch (error) {
      this.logger.error('Error loading vulnerabilities from OSV', { error: error.message });
      this.logger.info('Falling back to cache');

      // Fallback to cache for each package
      for (const pkg of packages) {
        try {
          await this.fetchPackageVulnerabilities(pkg);
        } catch (pkgError) {
          this.logger.warn('Failed to fetch vulnerabilities for package', {
            package: pkg.name,
            error: pkgError.message
          });
        }
      }
    }
  }

  /**
   * Fetches vulnerabilities for a specific package from REAL APIs
   */
  async fetchPackageVulnerabilities(packageInfo) {
    const { name, version } = packageInfo;
    const cacheKey = `${name}@${version}`;

    // Check cache first with integrity validation
    const cached = this.loadFromCache(cacheKey);
    if (cached) {
      this.vulnerabilities.set(cacheKey, cached);
      this.logger.debug('Loaded vulnerabilities from cache', { package: name, count: cached.length });
      return cached;
    }

    // Fetch from REAL OSV API
    try {
      this.logger.debug(`Querying OSV for ${name}@${version}`);
      const vulns = await this.osvDb.query(name, version, this.ecosystem);

      if (vulns.length > 0) {
        this.logger.info(`Found ${vulns.length} vulnerabilities for ${name}`);
      }

      // Cache results with integrity signature
      this.saveToCache(cacheKey, vulns);
      this.vulnerabilities.set(cacheKey, vulns);

      return vulns;
    } catch (error) {
      throw new VulnerabilityFetchError(
        `Failed to fetch vulnerabilities: ${error.message}`,
        name,
        { version, ecosystem: this.ecosystem }
      );
    }
  }

  /**
   * Maps vulnerabilities to specific functions in the call graph
   */
  mapVulnerableFunction(packageName, modulePath, functionName, vulnerability) {
    if (!this.functionVulnerabilities.has(packageName)) {
      this.functionVulnerabilities.set(packageName, new Map());
    }

    const funcMap = this.functionVulnerabilities.get(packageName);
    const key = `${modulePath}:${functionName}`;

    if (!funcMap.has(key)) {
      funcMap.set(key, []);
    }

    funcMap.get(key).push(vulnerability);
  }

  /**
   * Gets all vulnerabilities for a package
   */
  getVulnerabilities(packageName, version) {
    return this.vulnerabilities.get(`${packageName}@${version}`) || [];
  }

  /**
   * Loads from cache with integrity validation
   */
  loadFromCache(key) {
    const sanitizedKey = Validator.sanitizeCacheKey(key);
    const cacheFile = path.join(this.cacheDir, `${sanitizedKey}.json`);

    if (!fs.existsSync(cacheFile)) {
      return null;
    }

    try {
      // Validate file size before reading
      Validator.validateFileSize(cacheFile, 50 * 1024 * 1024); // Max 50MB cache file

      const data = fs.readFileSync(cacheFile, 'utf-8');

      // Validate JSON size before parsing
      Validator.validateJSONSize(data);

      const cached = JSON.parse(data);

      // Verify cache integrity using HMAC
      if (!this.verifyCacheIntegrity(cached)) {
        this.logger.warn('Cache integrity verification failed, ignoring cache', { key });
        return null;
      }

      // Check if cache is expired (24 hours)
      if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
        return cached.data;
      }

      this.logger.debug('Cache expired', { key, age: Date.now() - cached.timestamp });
    } catch (error) {
      this.logger.warn('Failed to load from cache', { key, error: error.message });
    }

    return null;
  }

  /**
   * Saves to cache with integrity signature
   */
  saveToCache(key, data) {
    const sanitizedKey = Validator.sanitizeCacheKey(key);
    const cacheFile = path.join(this.cacheDir, `${sanitizedKey}.json`);

    try {
      const cacheData = {
        timestamp: Date.now(),
        data
      };

      // Add HMAC signature for integrity verification
      cacheData.signature = this.generateCacheSignature(cacheData);

      fs.writeFileSync(cacheFile, JSON.stringify(cacheData), 'utf-8');
      this.logger.debug('Saved to cache', { key });
    } catch (error) {
      this.logger.error('Failed to save cache', { key, error: error.message });
      // Don't throw - caching is not critical
    }
  }

  /**
   * Generates HMAC signature for cache data integrity
   */
  generateCacheSignature(cacheData) {
    const { data, timestamp } = cacheData;
    const content = JSON.stringify({ data, timestamp });
    return crypto.createHmac('sha256', this.cacheSecret)
      .update(content)
      .digest('hex');
  }

  /**
   * Verifies cache data integrity using HMAC
   */
  verifyCacheIntegrity(cacheData) {
    if (!cacheData.signature) {
      return false; // No signature, can't verify
    }

    const expectedSignature = this.generateCacheSignature(cacheData);
    return cacheData.signature === expectedSignature;
  }

  /**
   * Clears cache
   */
  clearCache() {
    try {
      if (fs.existsSync(this.cacheDir)) {
        const files = fs.readdirSync(this.cacheDir);
        files.forEach(file => {
          const filePath = path.join(this.cacheDir, file);
          fs.unlinkSync(filePath);
        });
        this.logger.info('Cache cleared', { fileCount: files.length });
      }
    } catch (error) {
      throw new FileSystemError(
        `Failed to clear cache: ${error.message}`,
        this.cacheDir,
        'clear'
      );
    }
  }
}

module.exports = VulnerabilityDatabase;
