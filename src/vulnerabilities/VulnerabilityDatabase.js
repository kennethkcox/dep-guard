/**
 * GENERIC Vulnerability Database Manager
 * NO hardcoded vulnerabilities - uses REAL APIs
 * Works with ANY project structure, ANY vulnerabilities
 */

const fs = require('fs');
const path = require('path');
const OSVDatabase = require('./OSVDatabase');

class VulnerabilityDatabase {
  constructor(options = {}) {
    this.options = options;
    this.vulnerabilities = new Map(); // package@version -> [vulns]
    this.functionVulnerabilities = new Map(); // package -> {function -> vulns}
    this.cacheDir = options.cacheDir || path.join(process.cwd(), '.depguard-cache');
    this.ecosystem = options.ecosystem || 'javascript';

    // Use REAL OSV Database
    this.osvDb = new OSVDatabase(options);

    this.initializeCache();
  }

  /**
   * Initializes cache directory
   */
  initializeCache() {
    if (!fs.existsSync(this.cacheDir)) {
      fs.mkdirSync(this.cacheDir, { recursive: true });
    }
  }

  /**
   * Loads vulnerability data from REAL sources
   */
  async loadVulnerabilities(packages) {
    console.log(`Loading vulnerabilities for ${packages.length} packages from OSV...`);

    // Use batch query for efficiency
    try {
      const vulns = await this.osvDb.queryBatch(packages, this.ecosystem);

      vulns.forEach(vuln => {
        const cacheKey = `${vuln.package}@${vuln.version}`;

        if (!this.vulnerabilities.has(cacheKey)) {
          this.vulnerabilities.set(cacheKey, []);
        }

        this.vulnerabilities.get(cacheKey).push(vuln);

        // Cache it
        this.saveToCache(cacheKey, this.vulnerabilities.get(cacheKey));
      });

      console.log(`Found vulnerabilities in ${this.vulnerabilities.size} packages`);
    } catch (error) {
      console.error(`Error loading vulnerabilities: ${error.message}`);
      console.log('Falling back to cache...');

      // Fallback to cache for each package
      for (const pkg of packages) {
        await this.fetchPackageVulnerabilities(pkg);
      }
    }
  }

  /**
   * Fetches vulnerabilities for a specific package from REAL APIs
   */
  async fetchPackageVulnerabilities(packageInfo) {
    const { name, version } = packageInfo;
    const cacheKey = `${name}@${version}`;

    // Check cache first
    const cached = this.loadFromCache(cacheKey);
    if (cached) {
      this.vulnerabilities.set(cacheKey, cached);
      return cached;
    }

    // Fetch from REAL OSV API
    try {
      console.log(`Querying OSV for ${name}@${version}...`);
      const vulns = await this.osvDb.query(name, version, this.ecosystem);

      if (vulns.length > 0) {
        console.log(`  Found ${vulns.length} vulnerabilities`);
      }

      // Cache results
      this.saveToCache(cacheKey, vulns);
      this.vulnerabilities.set(cacheKey, vulns);

      return vulns;
    } catch (error) {
      console.error(`Failed to fetch vulnerabilities for ${name}: ${error.message}`);
      this.vulnerabilities.set(cacheKey, []);
      return [];
    }
  }

  /**
   * Maps vulnerabilities to specific functions in the call graph
   */
  mapVulnerableFunction(packageName, modulePath, functionName, vulnerability) {
    if (!this.functionVulnerabilities.has(packageName)) {
      this.functionVulnerabilities.set(packageName, new Map());
    }

    const funcMap = this.functionVulnerabilities.get(packageName);
    const key = `${modulePath}:${functionName}`;

    if (!funcMap.has(key)) {
      funcMap.set(key, []);
    }

    funcMap.get(key).push(vulnerability);
  }

  /**
   * Gets all vulnerabilities for a package
   */
  getVulnerabilities(packageName, version) {
    return this.vulnerabilities.get(`${packageName}@${version}`) || [];
  }

  /**
   * Loads from cache
   */
  loadFromCache(key) {
    const cacheFile = path.join(this.cacheDir, `${key.replace(/[^a-z0-9]/gi, '_')}.json`);

    if (fs.existsSync(cacheFile)) {
      try {
        const data = fs.readFileSync(cacheFile, 'utf-8');
        const cached = JSON.parse(data);

        // Check if cache is expired (24 hours)
        if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
          return cached.data;
        }
      } catch (error) {
        // Cache read failed, will fetch fresh data
      }
    }

    return null;
  }

  /**
   * Saves to cache
   */
  saveToCache(key, data) {
    const cacheFile = path.join(this.cacheDir, `${key.replace(/[^a-z0-9]/gi, '_')}.json`);

    try {
      fs.writeFileSync(cacheFile, JSON.stringify({
        timestamp: Date.now(),
        data
      }), 'utf-8');
    } catch (error) {
      console.error(`Failed to save cache: ${error.message}`);
    }
  }

  /**
   * Clears cache
   */
  clearCache() {
    if (fs.existsSync(this.cacheDir)) {
      const files = fs.readdirSync(this.cacheDir);
      files.forEach(file => {
        fs.unlinkSync(path.join(this.cacheDir, file));
      });
    }
  }
}

module.exports = VulnerabilityDatabase;
