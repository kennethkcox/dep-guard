/**
 * Multi-Source Vulnerability Database Aggregator
 *
 * Queries multiple threat intelligence sources and merges results:
 * - OSV (Open Source Vulnerabilities)
 * - NVD (National Vulnerability Database)
 * - GitHub Security Advisory
 * - EPSS (Exploit Prediction Scoring System)
 * - CISA KEV (Known Exploited Vulnerabilities)
 *
 * Provides comprehensive vulnerability data with enrichment
 */

const OSVDatabase = require('./OSVDatabase');
const NVDDatabase = require('./NVDDatabase');
const GitHubAdvisoryDatabase = require('./GitHubAdvisoryDatabase');
const EPSSEnricher = require('./EPSSEnricher');
const CISAKEVChecker = require('./CISAKEVChecker');
const { getLogger } = require('../utils/logger');

class MultiSourceVulnerabilityDatabase {
    constructor(options = {}) {
        this.options = options;
        this.logger = getLogger().child({ component: 'MultiSourceVulnDB' });

        // Initialize all sources
        this.osv = new OSVDatabase(options);
        this.nvd = new NVDDatabase(options);
        this.github = new GitHubAdvisoryDatabase(options);
        this.epss = new EPSSEnricher(options);
        this.kev = new CISAKEVChecker(options);

        // Configuration
        this.enabledSources = {
            osv: options.disableOSV !== true,
            nvd: options.enableNVD === true, // Disabled by default (rate limits)
            github: options.enableGitHub === true, // Disabled by default (requires token)
            epss: options.disableEPSS !== true,
            kev: options.disableKEV !== true
        };

        // Cache
        this.cache = new Map();
        this.initialized = false;
    }

    /**
     * Initialize all sources
     */
    async initialize() {
        if (this.initialized) {
            return;
        }

        this.logger.info('Initializing multi-source vulnerability database');

        // Initialize KEV catalog (contains frequently used data)
        if (this.enabledSources.kev) {
            try {
                await this.kev.initialize();
                this.logger.info('CISA KEV catalog initialized', {
                    count: this.kev.kevMap.size
                });
            } catch (error) {
                this.logger.warn('Failed to initialize KEV catalog', {
                    error: error.message
                });
            }
        }

        this.initialized = true;
    }

    /**
     * Query all enabled sources for a package
     */
    async query(packageName, version, ecosystem) {
        await this.initialize();

        const cacheKey = `${packageName}@${version}:${ecosystem}`;

        // Check cache
        if (this.cache.has(cacheKey)) {
            this.logger.debug('Retrieved from cache', { package: packageName });
            return this.cache.get(cacheKey);
        }

        const results = [];
        const promises = [];

        // Query OSV (primary source)
        if (this.enabledSources.osv) {
            promises.push(
                this.osv.query(packageName, version, ecosystem)
                    .then(vulns => ({ source: 'OSV', vulns }))
                    .catch(error => {
                        this.logger.warn('OSV query failed', {
                            package: packageName,
                            error: error.message
                        });
                        return { source: 'OSV', vulns: [] };
                    })
            );
        }

        // Query GitHub Advisory
        if (this.enabledSources.github && this.github.githubToken) {
            promises.push(
                this.github.queryByPackage(packageName, ecosystem)
                    .then(vulns => ({ source: 'GitHub', vulns }))
                    .catch(error => {
                        this.logger.warn('GitHub query failed', {
                            package: packageName,
                            error: error.message
                        });
                        return { source: 'GitHub', vulns: [] };
                    })
            );
        }

        // Query NVD (optional, rate-limited)
        if (this.enabledSources.nvd && this.nvd.apiKey) {
            promises.push(
                this.nvd.queryByKeyword(packageName, ecosystem)
                    .then(vulns => ({ source: 'NVD', vulns }))
                    .catch(error => {
                        this.logger.warn('NVD query failed', {
                            package: packageName,
                            error: error.message
                        });
                        return { source: 'NVD', vulns: [] };
                    })
            );
        }

        // Wait for all queries
        const sourceResults = await Promise.all(promises);

        // Merge results from all sources
        const mergedVulns = this.mergeResults(sourceResults, packageName, version);

        // Enrich with EPSS
        let enriched = mergedVulns;
        if (this.enabledSources.epss && mergedVulns.length > 0) {
            try {
                enriched = await this.epss.enrichVulnerabilities(mergedVulns);
                this.logger.debug('Enriched with EPSS', {
                    package: packageName,
                    count: enriched.filter(v => v.epss).length
                });
            } catch (error) {
                this.logger.warn('EPSS enrichment failed', { error: error.message });
            }
        }

        // Enrich with KEV
        if (this.enabledSources.kev && enriched.length > 0) {
            try {
                enriched = this.kev.enrichVulnerabilities(enriched);
                this.logger.debug('Enriched with KEV', {
                    package: packageName,
                    count: enriched.filter(v => v.kev).length
                });
            } catch (error) {
                this.logger.warn('KEV enrichment failed', { error: error.message });
            }
        }

        // Cache results
        this.cache.set(cacheKey, enriched);

        return enriched;
    }

    /**
     * Batch query multiple packages
     */
    async queryBatch(packages, ecosystem) {
        await this.initialize();

        this.logger.info('Batch querying vulnerabilities', {
            count: packages.length,
            ecosystem
        });

        const allResults = [];

        // OSV supports efficient batch queries
        if (this.enabledSources.osv) {
            try {
                const osvResults = await this.osv.queryBatch(packages, ecosystem);

                // Group by package
                const grouped = new Map();
                osvResults.forEach(vuln => {
                    const key = `${vuln.package}@${vuln.version}`;
                    if (!grouped.has(key)) {
                        grouped.set(key, []);
                    }
                    grouped.get(key).push(vuln);
                });

                // Convert to array
                grouped.forEach((vulns, key) => {
                    allResults.push(...vulns);
                });

                this.logger.info('OSV batch query complete', {
                    found: osvResults.length
                });
            } catch (error) {
                this.logger.error('OSV batch query failed', {
                    error: error.message
                });
            }
        }

        // For other sources, query individually if enabled
        // (Most don't support efficient batch queries)

        // Enrich all results with EPSS
        if (this.enabledSources.epss && allResults.length > 0) {
            try {
                const enriched = await this.epss.enrichVulnerabilities(allResults);
                allResults.splice(0, allResults.length, ...enriched);
            } catch (error) {
                this.logger.warn('Batch EPSS enrichment failed', {
                    error: error.message
                });
            }
        }

        // Enrich with KEV
        if (this.enabledSources.kev && allResults.length > 0) {
            try {
                const enriched = this.kev.enrichVulnerabilities(allResults);
                allResults.splice(0, allResults.length, ...enriched);
            } catch (error) {
                this.logger.warn('Batch KEV enrichment failed', {
                    error: error.message
                });
            }
        }

        return allResults;
    }

    /**
     * Merge results from multiple sources, deduplicating by CVE/GHSA ID
     */
    mergeResults(sourceResults, packageName, version) {
        const merged = new Map(); // ID -> vulnerability

        sourceResults.forEach(({ source, vulns }) => {
            if (!vulns || vulns.length === 0) return;

            vulns.forEach(vuln => {
                const id = vuln.id || vuln.cve || vuln.ghsaId;
                if (!id) return;

                if (merged.has(id)) {
                    // Merge with existing entry
                    const existing = merged.get(id);
                    merged.set(id, this.mergeVulnerability(existing, vuln, source));
                } else {
                    // New entry
                    merged.set(id, {
                        ...vuln,
                        sources: [source],
                        package: packageName,
                        version
                    });
                }
            });
        });

        return Array.from(merged.values());
    }

    /**
     * Merge two vulnerability entries from different sources
     */
    mergeVulnerability(existing, newVuln, source) {
        return {
            ...existing,
            ...newVuln,
            sources: [...new Set([...existing.sources, source])],
            // Prefer more detailed descriptions
            summary: newVuln.summary || existing.summary,
            description: newVuln.description || existing.description,
            // Keep all references
            references: [
                ...(existing.references || []),
                ...(newVuln.references || [])
            ].filter((v, i, a) => a.indexOf(v) === i), // Deduplicate
            // Merge CVSS scores (prefer v3 over v2)
            cvss: newVuln.cvssV3 || newVuln.cvss || existing.cvssV3 || existing.cvss || existing.cvssV2,
            // Merge severity (prefer higher severity)
            severity: this.mergeServerity(existing.severity, newVuln.severity)
        };
    }

    /**
     * Merge severity ratings (prefer higher severity)
     */
    mergeServerity(sev1, sev2) {
        const severityOrder = ['UNKNOWN', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];

        const idx1 = severityOrder.indexOf(sev1);
        const idx2 = severityOrder.indexOf(sev2);

        return idx2 > idx1 ? sev2 : sev1;
    }

    /**
     * Get vulnerability by ID (CVE, GHSA, etc.)
     */
    async getVulnerability(vulnId) {
        await this.initialize();

        const results = [];

        // Try OSV first
        if (this.enabledSources.osv && vulnId.startsWith('GHSA-')) {
            // OSV uses GHSA IDs
            // Note: OSV doesn't have direct ID lookup, would need to search
        }

        // Try NVD for CVEs
        if (this.enabledSources.nvd && vulnId.startsWith('CVE-')) {
            try {
                const nvdResult = await this.nvd.queryByCVE(vulnId);
                if (nvdResult && nvdResult.length > 0) {
                    results.push(...nvdResult);
                }
            } catch (error) {
                this.logger.warn('NVD query failed', { id: vulnId, error: error.message });
            }
        }

        // Try GitHub for GHSA
        if (this.enabledSources.github && vulnId.startsWith('GHSA-') && this.github.githubToken) {
            try {
                const ghResult = await this.github.queryByGHSA(vulnId);
                if (ghResult) {
                    results.push(ghResult);
                }
            } catch (error) {
                this.logger.warn('GitHub query failed', { id: vulnId, error: error.message });
            }
        }

        if (results.length === 0) {
            return null;
        }

        // Enrich with EPSS and KEV
        let enriched = results[0];

        if (this.enabledSources.epss) {
            enriched = await this.epss.enrichVulnerability(enriched);
        }

        if (this.enabledSources.kev) {
            enriched = this.kev.enrichVulnerability(enriched);
        }

        return enriched;
    }

    /**
     * Get statistics about enabled sources
     */
    getStatistics() {
        return {
            sources: this.enabledSources,
            kev: this.enabledSources.kev ? this.kev.getStatistics() : null,
            cacheSize: this.cache.size
        };
    }

    /**
     * Clear cache
     */
    clearCache() {
        this.cache.clear();
        this.epss.clearCache();
    }

    /**
     * Health check for all sources
     */
    async healthCheck() {
        const health = {
            osv: false,
            nvd: false,
            github: false,
            epss: false,
            kev: false
        };

        if (this.enabledSources.osv) {
            try {
                // Simple check - OSV is usually reliable
                health.osv = true;
            } catch (error) {
                this.logger.warn('OSV health check failed', { error: error.message });
            }
        }

        if (this.enabledSources.nvd && this.nvd.apiKey) {
            health.nvd = await this.nvd.healthCheck();
        }

        if (this.enabledSources.github && this.github.githubToken) {
            health.github = await this.github.healthCheck();
        }

        if (this.enabledSources.epss) {
            health.epss = await this.epss.healthCheck();
        }

        if (this.enabledSources.kev) {
            health.kev = await this.kev.healthCheck();
        }

        return health;
    }
}

module.exports = MultiSourceVulnerabilityDatabase;
