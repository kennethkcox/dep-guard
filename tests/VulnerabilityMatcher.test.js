/**
 * Tests for VulnerabilityMatcher
 */

const VulnerabilityMatcher = require('../src/utils/VulnerabilityMatcher');

describe('VulnerabilityMatcher', () => {
    let matcher;

    beforeEach(() => {
        matcher = new VulnerabilityMatcher();
    });

    describe('matchFunctionToVulnerability', () => {
        test('should match exact function name', () => {
            const vulns = [{
                id: 'TEST-001',
                affectedFunctions: ['template', 'merge']
            }];

            const result = matcher.matchFunctionToVulnerability('lodash', 'template', vulns);

            expect(result.matched).toBe(true);
            expect(result.confidence).toBeGreaterThan(0.9);
            expect(result.matchedVulns).toHaveLength(1);
        });

        test('should match full qualified function name', () => {
            const vulns = [{
                id: 'TEST-002',
                affectedFunctions: ['template']
            }];

            const result = matcher.matchFunctionToVulnerability('lodash', 'lodash.template', vulns);

            expect(result.matched).toBe(true);
            expect(result.confidence).toBeGreaterThan(0.9);
        });

        test('should not match unrelated function', () => {
            const vulns = [{
                id: 'TEST-003',
                affectedFunctions: ['template']
            }];

            const result = matcher.matchFunctionToVulnerability('lodash', 'map', vulns);

            expect(result.matched).toBe(false);
            expect(result.confidence).toBeLessThanOrEqual(0.5);
        });

        test('should match based on description heuristic', () => {
            const vulns = [{
                id: 'TEST-004',
                summary: 'Prototype pollution via merge function',
                affectedFunctions: [] // OSV might not have this
            }];

            const result = matcher.matchFunctionToVulnerability('lodash', 'merge', vulns);

            expect(result.matched).toBe(true);
            expect(result.confidence).toBeGreaterThan(0.6);
            expect(result.confidence).toBeLessThan(0.9);
        });

        test('should handle empty vulnerabilities array', () => {
            const result = matcher.matchFunctionToVulnerability('lodash', 'template', []);

            expect(result.matched).toBe(false);
            expect(result.confidence).toBe(0.5);
        });

        test('should handle multiple vulnerabilities', () => {
            const vulns = [
                {
                    id: 'TEST-005',
                    affectedFunctions: ['template']
                },
                {
                    id: 'TEST-006',
                    affectedFunctions: ['merge', 'set']
                }
            ];

            const result = matcher.matchFunctionToVulnerability('lodash', 'template', vulns);

            expect(result.matched).toBe(true);
            expect(result.matchedVulns).toHaveLength(1);
        });

        test('should cache results', () => {
            const vulns = [{
                id: 'TEST-007',
                affectedFunctions: ['template']
            }];

            const result1 = matcher.matchFunctionToVulnerability('lodash', 'template', vulns);
            const result2 = matcher.matchFunctionToVulnerability('lodash', 'template', vulns);

            expect(result1).toBe(result2); // Same object reference
        });
    });

    describe('calculateEnhancedConfidence', () => {
        test('should give high confidence for direct function match', () => {
            const confidence = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                callDepth: 0
            });

            expect(confidence).toBeGreaterThan(0.9);
        });

        test('should reduce confidence for deep call chains', () => {
            const shallow = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                callDepth: 1
            });

            const deep = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                callDepth: 5
            });

            expect(deep).toBeLessThan(shallow);
        });

        test('should reduce confidence for conditional paths', () => {
            const direct = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                isConditional: false
            });

            const conditional = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                isConditional: true
            });

            expect(conditional).toBeLessThan(direct);
        });

        test('should reduce confidence for error paths', () => {
            const normal = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                isErrorPath: false
            });

            const errorPath = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                isErrorPath: true
            });

            expect(errorPath).toBeLessThan(normal);
        });

        test('should reduce confidence for background jobs', () => {
            const normal = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                isBackgroundJob: false
            });

            const background = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                isBackgroundJob: true
            });

            expect(background).toBeLessThan(normal);
        });

        test('should handle combination of penalties', () => {
            const confidence = matcher.calculateEnhancedConfidence({
                hasDirectFunctionMatch: true,
                callDepth: 3,
                isConditional: true,
                isErrorPath: true
            });

            expect(confidence).toBeGreaterThan(0.1);
            expect(confidence).toBeLessThan(0.8);
        });

        test('should never go below minimum confidence', () => {
            const confidence = matcher.calculateEnhancedConfidence({
                hasPackageImport: true,
                callDepth: 10,
                isConditional: true,
                isErrorPath: true,
                isBackgroundJob: true
            });

            expect(confidence).toBeGreaterThanOrEqual(0.1);
        });
    });

    describe('_functionsMatch', () => {
        test('should match identical names', () => {
            expect(matcher._functionsMatch('template', 'template')).toBe(true);
        });

        test('should match qualified names', () => {
            expect(matcher._functionsMatch('lodash.template', 'template')).toBe(true);
            expect(matcher._functionsMatch('_lodash.template', 'template')).toBe(true);
        });

        test('should handle normalization', () => {
            expect(matcher._functionsMatch('Template', 'template')).toBe(true);
            expect(matcher._functionsMatch('my_template', 'mytemplate')).toBe(true);
        });

        test('should not match different functions', () => {
            expect(matcher._functionsMatch('template', 'merge')).toBe(false);
            expect(matcher._functionsMatch('templateString', 'template')).toBe(false);
        });
    });

    describe('_mentionsFunction', () => {
        test('should detect function in description', () => {
            expect(matcher._mentionsFunction('vulnerability in template function', 'template')).toBe(true);
            expect(matcher._mentionsFunction('using merge() to exploit', 'merge')).toBe(true);
            expect(matcher._mentionsFunction('via set method', 'set')).toBe(true);
        });

        test('should detect code-like mentions', () => {
            expect(matcher._mentionsFunction('_.template()', 'template')).toBe(true);
            expect(matcher._mentionsFunction('lodash::template', 'template')).toBe(true);
        });

        test('should not match unrelated text', () => {
            expect(matcher._mentionsFunction('this is a template for testing', 'merge')).toBe(false);
        });
    });

    describe('clearCache', () => {
        test('should clear internal cache', () => {
            const vulns = [{
                id: 'TEST-008',
                affectedFunctions: ['template']
            }];

            matcher.matchFunctionToVulnerability('lodash', 'template', vulns);
            expect(matcher.functionVulnCache.size).toBeGreaterThan(0);

            matcher.clearCache();
            expect(matcher.functionVulnCache.size).toBe(0);
        });
    });
});
