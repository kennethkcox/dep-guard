/**
 * Tests for VulnerabilityDatabase
 */

const VulnerabilityDatabase = require('../src/vulnerabilities/VulnerabilityDatabase');
const fs = require('fs');
const path = require('path');

describe('VulnerabilityDatabase', () => {
  let vulnDb;
  const testCacheDir = path.join(__dirname, '.test-cache');

  beforeEach(() => {
    vulnDb = new VulnerabilityDatabase({
      cacheDir: testCacheDir
    });
  });

  afterEach(() => {
    vulnDb.clearCache();
    if (fs.existsSync(testCacheDir)) {
      fs.rmSync(testCacheDir, { recursive: true, force: true });
    }
  });

  describe('initialization', () => {
    test('should create cache directory', () => {
      expect(fs.existsSync(testCacheDir)).toBe(true);
    });
  });

  describe('loadVulnerabilities', () => {
    test('should load vulnerabilities for packages', async () => {
      const packages = [
        { name: 'lodash', version: '4.17.20' }
      ];

      await vulnDb.loadVulnerabilities(packages);

      expect(vulnDb.vulnerabilities.size).toBeGreaterThan(0);
    });
  });

  describe('getVulnerabilities', () => {
    test('should return vulnerabilities for package', async () => {
      const packages = [
        { name: 'lodash', version: '4.17.20' }
      ];

      await vulnDb.loadVulnerabilities(packages);
      const vulns = vulnDb.getVulnerabilities('lodash', '4.17.20');

      expect(Array.isArray(vulns)).toBe(true);
      expect(vulns.length).toBeGreaterThan(0);
    });

    test('should return empty array for unknown package', () => {
      const vulns = vulnDb.getVulnerabilities('unknown-package', '1.0.0');
      expect(vulns).toEqual([]);
    });
  });

  describe('isVersionAffected', () => {
    test('should detect affected version', () => {
      const isAffected = vulnDb.isVersionAffected('4.17.20', ['<4.17.21']);
      expect(isAffected).toBe(true);
    });

    test('should detect unaffected version', () => {
      const isAffected = vulnDb.isVersionAffected('4.17.21', ['<4.17.21']);
      expect(isAffected).toBe(false);
    });
  });

  describe('compareVersions', () => {
    test('should compare versions correctly', () => {
      expect(vulnDb.compareVersions('1.0.0', '2.0.0')).toBeLessThan(0);
      expect(vulnDb.compareVersions('2.0.0', '1.0.0')).toBeGreaterThan(0);
      expect(vulnDb.compareVersions('1.0.0', '1.0.0')).toBe(0);
    });

    test('should handle different version lengths', () => {
      expect(vulnDb.compareVersions('1.0', '1.0.0')).toBe(0);
      expect(vulnDb.compareVersions('1.0.1', '1.0')).toBeGreaterThan(0);
    });
  });

  describe('calculatePriority', () => {
    test('should calculate priority based on CVSS', () => {
      const vuln = { cvss: 9.8, severity: 'CRITICAL', exploitMaturity: 'high' };
      const priority = vulnDb.calculatePriority(vuln);

      expect(priority).toBeGreaterThan(9);
    });

    test('should boost critical severity', () => {
      const critical = { cvss: 7.0, severity: 'CRITICAL', exploitMaturity: 'unproven' };
      const high = { cvss: 7.0, severity: 'HIGH', exploitMaturity: 'unproven' };

      const criticalPriority = vulnDb.calculatePriority(critical);
      const highPriority = vulnDb.calculatePriority(high);

      expect(criticalPriority).toBeGreaterThan(highPriority);
    });
  });

  describe('caching', () => {
    test('should cache vulnerability data', async () => {
      const packages = [{ name: 'lodash', version: '4.17.20' }];

      await vulnDb.loadVulnerabilities(packages);

      const cacheKey = 'lodash@4.17.20';
      const cached = vulnDb.loadFromCache(cacheKey);

      expect(cached).toBeDefined();
      expect(Array.isArray(cached)).toBe(true);
    });

    test('should load from cache on subsequent requests', async () => {
      const packages = [{ name: 'lodash', version: '4.17.20' }];

      await vulnDb.loadVulnerabilities(packages);
      const firstLoad = vulnDb.getVulnerabilities('lodash', '4.17.20');

      // Clear in-memory data but keep cache
      vulnDb.vulnerabilities.clear();

      await vulnDb.loadVulnerabilities(packages);
      const secondLoad = vulnDb.getVulnerabilities('lodash', '4.17.20');

      expect(secondLoad).toEqual(firstLoad);
    });

    test('should clear cache', () => {
      vulnDb.saveToCache('test', { data: 'test' });
      vulnDb.clearCache();

      const cached = vulnDb.loadFromCache('test');
      expect(cached).toBeNull();
    });
  });

  describe('processVulnerabilities', () => {
    test('should filter affected versions', () => {
      const vulns = [
        {
          id: 'CVE-1',
          affectedVersions: ['<1.0.0'],
          cvss: 5.0,
          exploitMaturity: 'unproven'
        }
      ];

      const processed = vulnDb.processVulnerabilities(vulns, 'pkg', '0.9.0');
      expect(processed.length).toBe(1);
      expect(processed[0].isAffected).toBe(true);
    });

    test('should filter out unaffected versions', () => {
      const vulns = [
        {
          id: 'CVE-1',
          affectedVersions: ['<1.0.0'],
          cvss: 5.0,
          exploitMaturity: 'unproven'
        }
      ];

      const processed = vulnDb.processVulnerabilities(vulns, 'pkg', '2.0.0');
      expect(processed.length).toBe(0);
    });
  });
});
