/**
 * Tests for VulnerabilityDatabase
 */

const VulnerabilityDatabase = require('../src/vulnerabilities/VulnerabilityDatabase');
const fs = require('fs');
const path = require('path');

describe('VulnerabilityDatabase', () => {
  let vulnDb;
  const testCacheDir = path.join(__dirname, '.test-cache');

  beforeEach(() => {
    vulnDb = new VulnerabilityDatabase({
      cacheDir: testCacheDir
    });
  });

  afterEach(() => {
    try {
      vulnDb.clearCache();
    } catch (e) {
      // Ignore cleanup errors
    }
    if (fs.existsSync(testCacheDir)) {
      fs.rmSync(testCacheDir, { recursive: true, force: true });
    }
  });

  describe('initialization', () => {
    test('should create cache directory', () => {
      expect(fs.existsSync(testCacheDir)).toBe(true);
    });

    test('should initialize with default options', () => {
      expect(vulnDb.vulnerabilities).toBeInstanceOf(Map);
      expect(vulnDb.functionVulnerabilities).toBeInstanceOf(Map);
    });

    test('should accept custom ecosystem', () => {
      const pyDb = new VulnerabilityDatabase({
        cacheDir: testCacheDir,
        ecosystem: 'pypi'
      });
      expect(pyDb.ecosystem).toBe('pypi');
    });
  });

  describe('loadVulnerabilities', () => {
    test('should load vulnerabilities for packages', async () => {
      const packages = [
        { name: 'lodash', version: '4.17.20' }
      ];

      await vulnDb.loadVulnerabilities(packages);

      // Should have processed the packages (may or may not find vulns)
      expect(vulnDb.vulnerabilities).toBeDefined();
    }, 30000);

    test('should handle empty package list', async () => {
      await vulnDb.loadVulnerabilities([]);
      expect(vulnDb.vulnerabilities.size).toBe(0);
    });

    test('should handle unknown packages gracefully', async () => {
      const packages = [
        { name: 'this-package-definitely-does-not-exist-12345', version: '1.0.0' }
      ];

      // Should not throw
      await expect(vulnDb.loadVulnerabilities(packages)).resolves.not.toThrow();
    }, 30000);
  });

  describe('getVulnerabilities', () => {
    test('should return empty array for unknown package', () => {
      const vulns = vulnDb.getVulnerabilities('unknown-package', '1.0.0');
      expect(vulns).toEqual([]);
    });

    test('should return vulnerabilities after loading', async () => {
      const packages = [
        { name: 'lodash', version: '4.17.20' }
      ];

      await vulnDb.loadVulnerabilities(packages);
      const vulns = vulnDb.getVulnerabilities('lodash', '4.17.20');

      expect(Array.isArray(vulns)).toBe(true);
    }, 30000);
  });

  describe('mapVulnerableFunction', () => {
    test('should map vulnerabilities to functions', () => {
      const vuln = { id: 'CVE-2021-23337', severity: 'CRITICAL' };

      vulnDb.mapVulnerableFunction('lodash', 'template.js', 'template', vuln);

      expect(vulnDb.functionVulnerabilities.has('lodash')).toBe(true);
      const funcMap = vulnDb.functionVulnerabilities.get('lodash');
      expect(funcMap.has('template.js:template')).toBe(true);
    });

    test('should accumulate multiple vulnerabilities for same function', () => {
      const vuln1 = { id: 'CVE-1', severity: 'HIGH' };
      const vuln2 = { id: 'CVE-2', severity: 'CRITICAL' };

      vulnDb.mapVulnerableFunction('pkg', 'mod.js', 'func', vuln1);
      vulnDb.mapVulnerableFunction('pkg', 'mod.js', 'func', vuln2);

      const funcMap = vulnDb.functionVulnerabilities.get('pkg');
      const vulns = funcMap.get('mod.js:func');
      expect(vulns.length).toBe(2);
    });
  });

  describe('caching', () => {
    test('should save to cache', () => {
      vulnDb.saveToCache('test-key', [{ id: 'CVE-1' }]);

      const cacheFile = path.join(testCacheDir, 'test-key.json');
      expect(fs.existsSync(cacheFile)).toBe(true);
    });

    test('should load from cache', () => {
      const testData = [{ id: 'CVE-TEST', severity: 'HIGH' }];
      vulnDb.saveToCache('test-key-2', testData);

      const loaded = vulnDb.loadFromCache('test-key-2');
      expect(loaded).toEqual(testData);
    });

    test('should return null for non-existent cache', () => {
      const loaded = vulnDb.loadFromCache('non-existent-key');
      expect(loaded).toBeNull();
    });

    test('should clear cache', () => {
      vulnDb.saveToCache('test-clear-1', { data: 1 });
      vulnDb.saveToCache('test-clear-2', { data: 2 });

      vulnDb.clearCache();

      expect(vulnDb.loadFromCache('test-clear-1')).toBeNull();
      expect(vulnDb.loadFromCache('test-clear-2')).toBeNull();
    });

    test('should verify cache integrity', () => {
      vulnDb.saveToCache('integrity-test', [{ id: 'CVE-1' }]);

      // Valid cache should load
      const loaded = vulnDb.loadFromCache('integrity-test');
      expect(loaded).toBeDefined();
    });

    test('should reject tampered cache', () => {
      vulnDb.saveToCache('tamper-test', [{ id: 'CVE-1' }]);

      // Tamper with the cache file
      const cacheFile = path.join(testCacheDir, 'tamper-test.json');
      const cached = JSON.parse(fs.readFileSync(cacheFile, 'utf-8'));
      cached.data = [{ id: 'CVE-TAMPERED' }]; // Modify without updating signature
      fs.writeFileSync(cacheFile, JSON.stringify(cached));

      // Should reject tampered cache
      const loaded = vulnDb.loadFromCache('tamper-test');
      expect(loaded).toBeNull();
    });
  });

  describe('cache key sanitization', () => {
    test('should handle special characters in package names', () => {
      // Should not throw
      vulnDb.saveToCache('@scope/package@1.0.0', [{ id: 'CVE-1' }]);

      const loaded = vulnDb.loadFromCache('@scope/package@1.0.0');
      expect(loaded).toBeDefined();
    });
  });
});
